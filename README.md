# Постановка задачи
Использовать ring buffer (циклический буфер) для организации
коммуникации между двумя независимыми процессами, распределёнными
на разных CPU. Один процесс выполняет роль writer (писатель), другой -
reader (читатель). Необходимо измерить и проанализировать задержки в
работе буфера.

# Задача:
Разработайте два независимых процесса на языке программирования C или
C++:
Writer: записывает данные в ring buffer. Данные для записи генерируются
с заданной частотой.
Reader: читает данные из ring buffer как только они становятся доступны.
Оба процесса должны быть оптимизированы для работы на отдельных CPU.
Ring Buffer:
Реализуйте механизм ring buffer, обеспечивающий thread-safe операции
записи и чтения между процессами.
Убедитесь, что ring buffer эффективно использует память и процессорное
время.

# Измерение задержек:
Измерьте время задержки от момента записи данных в буфер до момента их
чтения в другом процессе.
Соберите статистику задержек для различных частот записи данных.

# Как это выглядит? 
Процесс writer формирует сообщение размером от 24 до 70 байт и отправлается в кольцевой буфер. В сообщении содержится информация 
о времени отправки, а так же некоторая дополнительная информация, которая может быть отправлена. 

Процесс reader читает данные из буфера и производит замер времени, записывая измерения для дальнейшей обработки. 

# Под к реалиации ring buffer 
Кольцевой буфер будем реализовывать, так как описано [здесь](https://habr.com/ru/companies/otus/articles/557310/)
Синхронизации 2-х процессов будем производить при помощи SeqLock, а точнее его простой реализации. 
Переменную `mode` будем использовать как счеткик, и если она не четная, то чтение запрещено, если она не четная, то читать можно. 

Такой подход будет, лучше, чем подход основанный на mutex так как ожидается большое количество операций чтения из буфера. 

# Измерения
Измерения будем производить на ноутбуку со следующими характеристиками:
CPU: AMD Ryzen 7 3750H with Radeon Vega Mobile Gfx
L1: 356 KiB
L2: 2 MiB
L3: 4 MiB
ОЗУ: 16GB

Методика измерений:
Будем последовательно проводить измерения для буферов различного размера и расчитывать 99 процентиль для измерений, и после записывать их в следующую таблицу


Маленький буфер: $[4;256]$KB
Средний буфер  : $[512;4096]$KB
Большой буфер  : $[8;32]$MB


## Маленький буфер

### Графики измерений
|Размер буфера|25 cообщений|100 cообщений|250 cообщений|500 cообщений|750 cообщений|1000 cообщений|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|4KB|![](py/img/test_res_4KB_25.png)|![](py/img/test_res_4KB_100.png)|![](py/img/test_res_4KB_250.png)|![](py/img/test_res_4KB_500.png)|![](py/img/test_res_4KB_750.png)|![](py/img/test_res_4KB_1000.png)|
|16KB|![](py/img/test_res_16KB_25.png)|![](py/img/test_res_16KB_100.png)|![](py/img/test_res_16KB_250.png)|![](py/img/test_res_16KB_500.png)|![](py/img/test_res_16KB_750.png)|![](py/img/test_res_16KB_1000.png)|
|32KB|![](py/img/test_res_32KB_25.png)|![](py/img/test_res_32KB_100.png)|![](py/img/test_res_32KB_250.png)|![](py/img/test_res_32KB_500.png)|![](py/img/test_res_32KB_750.png)|![](py/img/test_res_32KB_1000.png)|
|256KB|![](py/img/test_res_256KB_25.png)|![](py/img/test_res_256KB_100.png)|![](py/img/test_res_256KB_250.png)|![](py/img/test_res_256KB_500.png)|![](py/img/test_res_256KB_750.png)|![](py/img/test_res_256KB_1000.png)|

### 99 процентиль
|Размер буфера|25 cообщений|100 cообщений|250 cообщений|500 cообщений|750 cообщений|1000 cообщений|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|4KB|1.34мкс|0.63мкс|0.45мкс|0.29мкс|0.26мкс|0.24мкс|
|16KB|1.47мкс|0.61мкс|0.42мкс|0.41мкс|0.28мкс|0.26мкс|
|32KB|1.16мкс|0.51мкс|0.46мкс|0.35мкс|0.27мкс|0.28мкс|
|256KB|14.75мкс|0.69мкс|0.45мкс|0.41мкс|0.29мкс|0.28мкс|

### Графическое отображение 99 процентиля:
![](./py/small_buffer_size.png)


# Буфер среднего размера 


### Графики измерений
|Размер буфера|250 cообщений|500 cообщений|750 cообщений|1000 cообщений|2000 cообщений|
|:-:|:-:|:-:|:-:|:-:|:-:|
|512KB|![](py/img/test_res_512KB_250.png)|![](py/img/test_res_512KB_500.png)|![](py/img/test_res_512KB_750.png)|![](py/img/test_res_512KB_1000.png)|![](py/img/test_res_512KB_2000.png)|
|1024KB|![](py/img/test_res_1024KB_250.png)|![](py/img/test_res_1024KB_500.png)|![](py/img/test_res_1024KB_750.png)|![](py/img/test_res_1024KB_1000.png)|![](py/img/test_res_1024KB_2000.png)|
|2048KB|![](py/img/test_res_2048KB_250.png)|![](py/img/test_res_2048KB_500.png)|![](py/img/test_res_2048KB_750.png)|![](py/img/test_res_2048KB_1000.png)|![](py/img/test_res_2048KB_2000.png)|
|4096KB|![](py/img/test_res_4096KB_250.png)|![](py/img/test_res_4096KB_500.png)|![](py/img/test_res_4096KB_750.png)|![](py/img/test_res_4096KB_1000.png)|![](py/img/test_res_4096KB_2000.png)|

### 99 процентиль
|Размер буфера|250 cообщений|500 cообщений|750 cообщений|1000 cообщений|2000 cообщений|
|:-:|:-:|:-:|:-:|:-:|:-:|
|512KB|0.46мкс|0.35мкс|0.33мкс|0.27мкс|0.19мкс|
|1024KB|0.81мкс|0.39мкс|0.31мкс|0.26мкс|0.20мкс|
|2048KB|10.38мкс|0.61мкс|1.66мкс|1.10мкс|0.37мкс|
|4096KB|15.82мкс|13.03мкс|12.50мкс|2.10мкс|0.20мкс|

### Графическое отображение 99 процентиля:
![](./py/mid_buffer_size.png)

# Буфер большого размера

### Графики измерений
|Размер буфера|500 cообщений|1000 cообщений|1500 cообщений|2000 cообщений|4000 cообщений|
|:-:|:-:|:-:|:-:|:-:|:-:|
|8MB|![](py/img/test_res_8MB_500.png)|![](py/img/test_res_8MB_1000.png)|![](py/img/test_res_8MB_1500.png)|![](py/img/test_res_8MB_2000.png)|![](py/img/test_res_8MB_4000.png)|
|16MB|![](py/img/test_res_16MB_500.png)|![](py/img/test_res_16MB_1000.png)|![](py/img/test_res_16MB_1500.png)|![](py/img/test_res_16MB_2000.png)|![](py/img/test_res_16MB_4000.png)|
|32MB|![](py/img/test_res_32MB_500.png)|![](py/img/test_res_32MB_1000.png)|![](py/img/test_res_32MB_1500.png)|![](py/img/test_res_32MB_2000.png)|![](py/img/test_res_32MB_4000.png)|

### 99 процентиль
|Размер буфера|500 cообщений|1000 cообщений|1500 cообщений|2000 cообщений|4000 cообщений|
|:-:|:-:|:-:|:-:|:-:|:-:|
|8MB|14.23мкс|11.89мкс|6.41мкс|2.14мкс|0.20мкс|
|16MB|14.39мкс|11.95мкс|5.97мкс|5.27мкс|4.32мкс|
|32MB|9.71мкс|6.99мкс|5.58мкс|5.15мкс|4.52мкс|

### Графическое отображение 99 процентиля:
![](./py/big_buffer_size.png)


# Выволды
1. Как и ожидалось лучшим вариантом из всех оказался тот, когда буфер был не больше, чем кэш 3 его уровня. При достаточной загрузке процессора получается добиться стабильныз показателей в 0.4 - 0.2 мкс.
2. Важно, что бы процесс загрузил систему, потому что иначе OC может переключать контекст и будет происходить выгрузка данных в кэш высокого уровня или восе в оперативную память 
3. Значительно замедление видно при условии, когда размер буфера превышает размер буфера в 4 и более раз, даже при значительной загрузке CPU получается добиться показателей 4.3-4.5 мкс 


# Примечение 1
Опишу эффект связанный с особенным поведением функции mmap и manmap
При не корректном вызове mmap и последующем вызове manmap возникает ошибка со следующим сообщением:
Inconsistency detected by ld.so: dl-fini.c: 92: _dl_fini: Assertion `ns != LM_ID_BASE || i == nloaded' failed!
И при тестированни на объеме данных <= размера буфера и его не полной загрузке (не требуется воспользоваться переходом между виртуальными страницами) не возникает никаких проблем с работой программы. А вот если произойдет переполнение, то 
уже возникнет segmenation fauilt, который будет весьма тяжело отследить. 

Соответсвенно в случае появления подобной ошибки и знании, того, что в коже происходит работы с mmap,
самым верным способом отловить ее будет проверить все вызовы mmap и найти промах по разметке в виртуальные страницы. 

# Примечание 2
Для генерации png изображений перейти в папк `py` и запустить скрипт plot.py 


Требования к запуску:
```
matplotlib
pandas
numpy
```